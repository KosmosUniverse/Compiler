options {
  LOOKAHEAD = 1;
  IGNORE_CASE = true;
  MULTI = true;
  VISITOR = true;
}

PARSER_BEGIN(CodeGenerator)

import java.util.ArrayList;

public class CodeGenerator {
  public static STable st = new STable();
  public static ArrayList<String> errors = new ArrayList<String>();
  public static ArrayList<String> warnings = new ArrayList<String>();

  public static void main(String args[]) throws ParseException {
    CodeGenerator tokens;
    if (args.length == 0) {
      System.out.println("Reading from standard input ...");
      tokens = new CodeGenerator(System.in);
    } else if (args.length == 1) {
      System.out.println("Reading from file " + args[0] + " ...");
      try {
        tokens = new CodeGenerator(new java.io.FileInputStream(args[0]));
      } catch (java.io.FileNotFoundException e) {
        System.out.println("File " + args[0] + " not found.");
        return ;
      }
    } else {
      System.out.println("Usage:");
      System.out.println("	- java CodeGenerator < inputFile");
      System.out.println("	- java CodeGenerator inputFile");
      return ;
    }
    try {
      SimpleNode root = tokens.start();

      st.checkAllUsed(warnings);
      if (!warnings.isEmpty())
        System.out.println("WARNING:" + makeString(warnings));

      if (!errors.isEmpty()) {
        throw new ParseException(makeString(errors));
      }

      System.out.println("Java program parsed successfully.");
/*
      PrintVisitor pv = new PrintVisitor();
      root.jjtAccept(pv, null);
      */
    } catch (ParseException e) {
      System.out.println("Encountered error during parse:" + e.getMessage());
    }
  }

  public static String makeString(ArrayList<String> list) {
    String str = "\n";

    for (int i = 0; i < list.size(); i++) {
      str += "\t- " + list.get(i) + "\n";
    }

    return (str);
  }
}

PARSER_END(CodeGenerator)

TOKEN_MGR_DECLS:
{
  static int comsLevel = 0;
}

SKIP: {
  " "
  | "\t"
  | "\n" 
  | "\r"
  | "\f"
}

SKIP : /* COMMENTS */
{
  <SINGLE_LINE_COMMENT: "//" (~["\n","\r"])* ("\n"|"\r"|"\r\n")>
| "/*" {comsLevel++;}: COMS
}

<COMS> SKIP:
{
  "/*" {comsLevel++;}
  | "*/" {comsLevel--; if (comsLevel == 0) SwitchTo(DEFAULT);}
  | <~[]>
}

TOKEN: { //Reseved words
  <VAR: "var">
  | <CONST: "const">
  | <INTEGER: "integer">
  | <BOOLEAN: "boolean">
  | <VOID: "void">
  | <IF: "if">
  | <MAIN: "main">
  | <ELSE: "else">
  | <WHILE: "while">
  | <SQIP: "skip">
  | <RETURN: "return">
  | <TRUE: "true">
  | <FALSE: "false">
}

TOKEN: { //Symbols
  <LBRACE: "{">
  | <RBRACE: "}">
  | <LPARENT: "(">
  | <RPARENT: ")">
  | <COMA: ",">
  | <SEMICOLON: ";">
  | <PLUS: "+">
  | <MINUS: "-">
  | <TILDE: "~">
  | <ASSIGN: "=">
  | <EQUAL: "==">
  | <NEQUAL: "!=">
  | <GREATEST: ">">
  | <GEQUAL: ">=">
  | <LOWEST: "<">
  | <LEQUAL: "<=">
  | <OR: "||">
  | <AND: "&&">
  | <TPOINT:":">
}

TOKEN: { // Usable
  <NUMBER: "0" | ["1"-"9"] (["0"-"9"])* | "-"["1"-"9"] (["0"-"9"])*>
  | <IDENTIFIER: ["a"-"z","A"-"Z"] (["a"-"z","A"-"Z","0"-"9","_"])*>
}

SimpleNode start() : {}
{
  (decl_list() function_list() main()<EOF>) {return jjtThis;}
}

void decl_list() #void : {}
{
  ((var_decl() | const_decl())<SEMICOLON>decl_list()) #decl_list(2)
  | { } #decl_empty(0)
}

void var_decl() : {Token t; String type;}
{
  (<VAR>t = <IDENTIFIER><TPOINT>type = type()) {jjtThis.value = t.image; st.checkElemDef(t.image, errors); st.addElem(t.image, type, false, false);}
}

void const_decl() : {Token t; String type;}
{
  (<CONST>t = <IDENTIFIER><TPOINT>type = type()<ASSIGN>expression_one()) {jjtThis.value = t.image; st.checkElemDef(t.image, errors); st.addElem(t.image, type, true, false);}
}

void function_list() #void : {}
{
  ((function() | function_void()) function_list()) #function_list(2)
  | { } #function_empty(0)
}

void function() : {Token t; String type; int count = 0;}
{
  (type = type()t = <IDENTIFIER> {st.checkElemDef(t.image, errors); st.addElem(t.image, type, false, true); st.addBreak();} <LPARENT>parameter_list(count)<RPARENT><LBRACE>decl_list()statement_block()<RETURN><LPARENT>expression_one()<RPARENT><SEMICOLON><RBRACE>) {jjtThis.value = t.image; st.addFuncParam(t.image, count); st.removeUntilBreak();}
}

void function_void() : {Token t; int count = 0;}
{
  (<VOID>t = <IDENTIFIER> {st.checkElemDef(t.image, errors); st.addElem(t.image, "void", false, true); st.addBreak();} <LPARENT>parameter_list(count)<RPARENT><LBRACE>decl_list()statement_block()<RETURN><LPARENT><RPARENT><SEMICOLON><RBRACE>) {jjtThis.value = t.image; st.addFuncParam(t.image, count); st.removeUntilBreak();}
}

String type() : {Token t;}
{
  t = <INTEGER> {return t.image;}
  | t = <BOOLEAN> {return t.image;}
}

void parameter_list(int count) #void : {Token t; String type;}
{
  (t = <IDENTIFIER><TPOINT>type = type() {st.addElem(t.image, type, false, false);} parameter_elem(count)) {jjtThis.value = t.image; count++;} #parameter_list(2)
  | { } #parameter_empty(0)
}

void parameter_elem(int count) #void : {Token t; String type;}
{
  (<COMA>t = <IDENTIFIER><TPOINT>type = type() parameter_elem(count)) {st.addElem(t.image, type, false, false);} #parameter_elem(2)
  | { } #parameter_elem_empty(0)
}

void main() : {}
{
  (<MAIN> {st.checkElemDef("main", errors); st.addElem("main", "void", false, true); st.addBreak();} <LBRACE>decl_list()statement_block()<RBRACE>) {st.removeUntilBreak();}
}

void statement_block() #void: {}
{
  (statement_elem() statement_block()) #statement_block(2)
  | { } #statement_empty(0)
}

void statement_elem() #void : {Token t;}
{
  (t = <IDENTIFIER>identifier_elem(t.image)) {jjtThis.value = t.image;} #stmt_id(1)
  | (<LBRACE>statement_block()<RBRACE>) #stmt_stmt(0)
  | (<IF>condition()<LBRACE>statement_block()<RBRACE><ELSE><LBRACE>statement_block()<RBRACE>) #stmt_if(3)
  | (<WHILE>condition()<LBRACE>statement_block()<RBRACE>) #stmt_while(2)
  | (<SQIP><SEMICOLON>) #void
}

void identifier_elem(String name) #void : {int count = 0;}
{
  (<ASSIGN>expression_one()<SEMICOLON>) #assign(1) {st.checkElemRedef(name, errors); st.checkElemUse(name, false, 0, errors);}
  | (<LPARENT>arg_list(count)<RPARENT><SEMICOLON>) #funcarg(1) {st.checkElemUse(name, true, count, errors);}
}

void expression() : {}
{
  (expression_one() [comp_op() expression()])
}

void expression_one() : {}
{
  (fragment() [binary_op() expression_one()])
}

void fragment() #void : {Token t; Boolean isFunc; int count = 0;}
{
  (t = <IDENTIFIER>isFunc = is_func(count)) {jjtThis.value = t.image; st.checkElemUse(t.image, isFunc, count, errors);} #frag_id(1)
  | (<MINUS>t = <IDENTIFIER>) {jjtThis.value = "-" + t.image; st.checkElemUse(t.image, false, 0, errors);} #frag_minus(0)
  | t = <NUMBER> {jjtThis.value = t.image;} #frag_num(0)
  | t = <TRUE> {jjtThis.value = t.image;} #frag_bool(0)
  | t = <FALSE> {jjtThis.value = t.image;} #frag_bool(0)
  | (<LPARENT>condition()<RPARENT>) #frag_cond(1)
}

Boolean is_func(int count) : {}
{
  (<LPARENT>arg_list(count)<RPARENT>){return true;}
  | { } {return false;}
}

void binary_op() : {Token t;}
{
  t = <PLUS> {jjtThis.value = t.image;}
  | t = <MINUS> {jjtThis.value = t.image;}
}

void comp_op() : {Token t;}
{
  t = <EQUAL> {jjtThis.value = t.image;}
  | t = <NEQUAL> {jjtThis.value = t.image;}
  | t = <GEQUAL> {jjtThis.value = t.image;}
  | t = <LEQUAL> {jjtThis.value = t.image;}
  | t = <GREATEST> {jjtThis.value = t.image;}
  | t = <LOWEST> {jjtThis.value = t.image;}
}

void condition() : {}
{
  (condition_one() [op() condition()])
}

void condition_one() #void : {}
{
  (<TILDE><LPARENT>condition()<RPARENT>) #tildecond(1)
  | expression() #condexpr(1)
}

void op() : {Token t;}
{
  t = <OR> {jjtThis.value = t.image;}
  | t = <AND> {jjtThis.value = t.image;}
}

void arg_list(int count) #void : {Token t;}
{
  (t = <IDENTIFIER>arg_elem(count)) {jjtThis.value = t.image; st.checkElemUse(t.image, false, 0, errors); count++;} #arg_list(1)
  | { } #arg_empty(0)
}

void arg_elem(int count) #void : {Token t;}
{
  (<COMA>t = <IDENTIFIER> arg_elem(count)) {st.checkElemUse(t.image, false, 0, errors); count++;} #arg_elem(1)
  | { } #arg_elem_empty(0)
}